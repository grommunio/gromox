// SPDX-License-Identifier: AGPL-3.0-or-later
// SPDX-FileCopyrightText: 2021–2025 grommunio GmbH
// This file is part of Gromox.
#include <cerrno>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <memory>
#include <new>
#include <libHX/endian.h>
#include <libHX/option.h>
#include <libHX/scope.hpp>
#include <gromox/exmdb_client.hpp>
#include <gromox/svc_loader.hpp>
#include "genimport.hpp"

using namespace gromox;

struct mboxparam {
	mboxparam(bool pvt, unsigned int userid);
	int second_init();

	FLATUID dbguid{};
	uint64_t root_fld = 0, cn_limit = 0;
	mapitime_t time_limit{};
	bool ispublic = false;
};

static constexpr cpid_t codepage = CP_UTF8;
static unsigned int g_dry_run, g_skip_msg, g_force_fix;
static char *g_primail;

static constexpr HXoption g_options_table[] = {
	{nullptr, 'e', HXTYPE_STRING, &g_primail, nullptr, nullptr, 0, "Primary e-mail address of store", "ADDR"},
	{nullptr, 'n', HXTYPE_NONE, &g_dry_run, nullptr, nullptr, 0, "Perform a dry run"},
	{"force-fix", 0, HXTYPE_NONE, &g_force_fix, {}, {}, {}, "Reset CN/PCL of all objects even if good"},
	{"skip-msg", 0, HXTYPE_NONE, &g_skip_msg, {}, {}, {}, "Skip messages / inspect only folder object"},
	HXOPT_AUTOHELP,
	HXOPT_TABLEEND,
};

static FLATUID st_private, st_public;
static constexpr uint32_t check_tags1[] =
	{PidTagFolderId, PidTagMid, PR_LAST_MODIFICATION_TIME, PR_FOLDER_TYPE,
	PR_CHANGE_KEY, PR_PREDECESSOR_CHANGE_LIST};
static constexpr PROPTAG_ARRAY check_tags =
	{std::size(check_tags1), deconst(check_tags1)};

mboxparam::mboxparam(bool pub, unsigned int user_id) :
	dbguid(pub ? rop_util_make_domain_guid(user_id) : rop_util_make_user_guid(user_id)),
	root_fld(rop_util_make_eid_ex(1, pub ? PUBLIC_FID_ROOT : PRIVATE_FID_ROOT)),
	time_limit(rop_util_unix_to_nttime(std::chrono::system_clock::now())),
	ispublic(pub)
{}

int mboxparam::second_init()
{
	uint64_t v;
	if (!exmdb_client->allocate_cn(g_storedir, &v))
		return -EIO;
	cn_limit = rop_util_get_gc_value(v);
	return 0;
}

static inline bool change_key_size_ok(const BINARY *b)
{
	/* Not much else to do. MS-OXCFXICS v24 §2.2.2.2 */
	return b != nullptr && b->cb >= 16 && b->cb <= 24;
}

/**
 * @b:   PR_CHANGE_KEY of the message/folder
 * @ts:  PR_LAST_MOD of the message/folder
 * @mbp: CK & LASTMOD limits
 *
 * Returns false then the CK is deemed not ok, e.g. when the CN is too high.
 */
static inline bool change_key_gc_ok(const BINARY *b, const mapitime_t *ts,
    const mboxparam &mbp)
{
	if (b == nullptr)
		return false;
	/* Don't bother with CHANGE_KEYs not generated by this mailbox. */
	if (b->cb != 22)
		return true;
	if (memcmp(b->pb, &mbp.dbguid, sizeof(mbp.dbguid)) != 0)
		return true;

	char flatcn[8]{};
	memcpy(&flatcn[2], &b->pb[16], 6);
	auto cn = be64p_to_cpu(flatcn);
	if (ts != nullptr && *ts < mbp.time_limit && cn >= mbp.cn_limit)
		/* CN too high */
		return false;

	return true;
}

static inline bool pcl_ok(const BINARY *b, const mapitime_t *ts,
    const mboxparam &mbp)
{
	if (b == nullptr)
		return false;
	PCL pcl;
	if (!pcl.deserialize(b))
		return false;
	for (const auto &xid : pcl) {
		if (xid.guid.operator!=(mbp.dbguid)) /* syntax hack for g++-12 */
			continue;
		if (xid.size != 22)
			return false;
		auto cn = rop_util_gc_to_value(xid.local_to_gc());
		if (ts != nullptr && *ts < mbp.time_limit && cn >= mbp.cn_limit)
			return false; /* CN too high */
	}
	return true;
}

static int repair_object(uint64_t objid, mapi_object_type ot, const BINARY *oldpcl)
{
	tpropval_array_ptr props(tpropval_array_init());
	if (props == nullptr)
		return -ENOMEM;
	uint64_t change_num = 0;
	if (!exmdb_client->allocate_cn(g_storedir, &change_num)) {
		fprintf(stderr, "exm: allocate_cn(fld) RPC failed\n");
		return -EIO;
	}
	auto ret = exm_set_change_keys(props.get(), change_num, oldpcl);
	if (ret < 0)
		return ret;
	PROBLEM_ARRAY problems;
	bool ok = false;
	if (ot == MAPI_FOLDER)
		ok = exmdb_client->set_folder_properties(g_storedir, codepage,
		     objid, props.get(), &problems);
	else if (ot == MAPI_MESSAGE)
		ok = exmdb_client->set_message_properties(g_storedir, nullptr,
		     codepage, objid, props.get(), &problems);
	else
		abort();
	if (!ok) {
		fprintf(stderr, "exm: set_folder_properties RPC failed\n");
		return -EIO;
	}
	printf(" (new key: %llxh)\n", static_cast<unsigned long long>(rop_util_get_gc_value(change_num)));
	return 0;
}

static int inspect_message_row(const TPROPVAL_ARRAY &props, const mboxparam &mbp)
{
	TPROPVAL_ARRAY newprops{};
	auto mid = props.get<const uint64_t>(PidTagMid);
	if (mid == nullptr)
		return 0;
	auto ts   = props.get<const mapitime_t>(PR_LAST_MODIFICATION_TIME);
	auto ckey = props.get<const BINARY>(PR_CHANGE_KEY);
	auto pcl  = props.get<const BINARY>(PR_PREDECESSOR_CHANGE_LIST);
	if (pcl != nullptr && pcl->cb >= 510) {
		if (!exmdb_client->get_message_properties(g_storedir, nullptr,
		    codepage, *mid, &check_tags, &newprops))
			return -EIO;
		pcl = newprops.get<const BINARY>(PR_PREDECESSOR_CHANGE_LIST);
	}
	auto k1   = change_key_size_ok(ckey);
	auto k2   = change_key_gc_ok(ckey, ts, mbp);
	auto k3   = pcl_ok(pcl, ts, mbp);

	auto goodpoints = g_force_fix ? 0 : k1 + k2 + k3;
	if (goodpoints < 3) {
		printf("message %llxh [%c%c%c]", static_cast<unsigned long long>(rop_util_get_gc_value(*mid)),
			!k1 ? 'Z' : '-', !k2 ? 'N' : '-', !k3 ? 'P' : '-');
		if (g_dry_run) {
			printf("\n");
		} else {
			auto ret = repair_object(*mid, MAPI_MESSAGE, pcl);
			if (ret != 0)
				return ret;
		}
	}
	return 0;
}

static int inspect_folder_row(const TPROPVAL_ARRAY &props, const mboxparam &mbp)
{
	TPROPVAL_ARRAY newprops{};
	auto fid = props.get<const uint64_t>(PidTagFolderId);
	if (fid == nullptr)
		return 0;
	auto ftype = props.get<const uint32_t>(PR_FOLDER_TYPE);
	auto ts   = props.get<const mapitime_t>(PR_LAST_MODIFICATION_TIME);
	auto ckey = props.get<const BINARY>(PR_CHANGE_KEY);
	auto pcl  = props.get<const BINARY>(PR_PREDECESSOR_CHANGE_LIST);
	if (pcl != nullptr && pcl->cb >= 510) {
		if (!exmdb_client->get_folder_properties(g_storedir, codepage,
		    *fid, &check_tags, &newprops))
			return -EIO;
		pcl = newprops.get<const BINARY>(PR_PREDECESSOR_CHANGE_LIST);
	}
	auto k1   = change_key_size_ok(ckey);
	auto k2   = change_key_gc_ok(ckey, ts, mbp);
	auto k3   = pcl_ok(pcl, ts, mbp);

	auto goodpoints = g_force_fix ? 0 : k1 + k2 + k3;
	if (goodpoints < 3) {
		printf("folder %llxh [%c%c%c]", static_cast<unsigned long long>(rop_util_get_gc_value(*fid)),
			!k1 ? 'Z' : '-', !k2 ? 'N' : '-', !k3 ? 'P' : '-');
		if (g_dry_run) {
			printf("\n");
		} else {
			auto ret = repair_object(*fid, MAPI_FOLDER, pcl);
			if (ret != 0)
				return ret;
		}
	}

	if (g_skip_msg)
		return 0;
	if (ftype != nullptr && *ftype != FOLDER_GENERIC)
		/*
		 * Skip recursing into search folders; that would just
		 * duplicate work.
		 */
		return 0;

	uint32_t table_id = 0, row_count = 0;
	if (!exmdb_client->load_content_table(g_storedir, codepage, *fid,
	    nullptr, 0, nullptr, nullptr, &table_id, &row_count))
		return -EIO;
	TARRAY_SET tset{};
	if (!exmdb_client->query_table(g_storedir, nullptr, codepage, table_id,
	    &check_tags, 0, row_count, &tset)) {
		fprintf(stderr, "exm: query_table RPC failed\n");
		return -EIO;
	}
	exmdb_client->unload_table(g_storedir, table_id);
	for (size_t i = 0; i < tset.count; ++i) {
		auto ret = inspect_message_row(*tset.pparray[i], mbp);
		if (ret != 0)
			return ret;
	}
	return 0;
}

static int repair_mbox()
{
	/* Record current time and highest Change Number */
	mboxparam mbp(g_public_folder, g_user_id);
	auto ret = mbp.second_init();
	if (ret != 0)
		return ret;

	uint32_t table_id = 0, row_num = 0;
	TPROPVAL_ARRAY props{};
	if (!exmdb_client->get_folder_properties(g_storedir, codepage,
	    mbp.root_fld, &check_tags, &props))
		return -EIO;
	if (inspect_folder_row(props, mbp) < 0)
		return -EIO;
	/*
	 * This does not return the root entry itself, just its subordinates.
	 * Might want to refine later.
	 */
	if (!exmdb_client->load_hierarchy_table(g_storedir, mbp.root_fld,
	    nullptr, TABLE_FLAG_DEPTH | TABLE_FLAG_NONOTIFICATIONS,
	    nullptr, &table_id, &row_num)) {
		fprintf(stderr, "exm: load_hierarchy_table RPC failed\n");
		return -EIO;
	}
	TARRAY_SET tset{};
	if (!exmdb_client->query_table(g_storedir, nullptr, codepage, table_id,
	    &check_tags, 0, row_num, &tset)) {
		fprintf(stderr, "exm: query_table RPC failed\n");
		return -EIO;
	}
	exmdb_client->unload_table(g_storedir, table_id);
	for (size_t i = 0; i < tset.count; ++i) {
		auto ret = inspect_folder_row(*tset.pparray[i], mbp);
		if (ret != 0)
			return ret;
	}
	return 0;
}

static constexpr static_module g_dfl_svc_plugins[] = {
	{"libgxs_mysql_adaptor.so", SVC_mysql_adaptor},
	{"libgxs_ruleproc.so", SVC_ruleproc},
};

int main(int argc, char **argv)
{
	if (HX_getopt5(g_options_table, argv, &argc, &argv,
	    HXOPT_USAGEONERR) != HXOPT_ERR_SUCCESS)
		return EXIT_FAILURE;
	auto cl_0 = HX::make_scope_exit([=]() { HX_zvecfree(argv); });
	if (g_primail == nullptr) {
		fprintf(stderr, "Usage: cgkrepair -e primary_mailaddr\n");
		return EXIT_FAILURE;
	}
	st_private = gx_dbguid_store_private;
	st_public  = gx_dbguid_store_public;
	service_init({nullptr, g_dfl_svc_plugins, 1});
	auto cl_1 = HX::make_scope_exit(service_stop);
	if (service_run_early() != 0 || service_run() != 0) {
		fprintf(stderr, "service_run: failed\n");
		return EXIT_FAILURE;
	}
	if (gi_setup_from_user(g_primail) != EXIT_SUCCESS)
		return EXIT_FAILURE;
	if (gi_startup_client() != EXIT_SUCCESS)
		return EXIT_FAILURE;
	auto cl_2 = HX::make_scope_exit(gi_shutdown);
	auto ret = repair_mbox();
	if (ret == -ENOMEM) {
		fprintf(stderr, "Insufficient system memory.\n");
		ret = EXIT_FAILURE;
	} else if (ret != 0) {
		fprintf(stderr, "The operation did not complete.\n");
		ret = EXIT_FAILURE;
	} else if (ret == 0) {
		ret = EXIT_SUCCESS;
	}
	return ret;
}
